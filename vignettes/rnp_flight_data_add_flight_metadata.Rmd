---
title: "Dealing with flight data"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
devtools::load_all()
```

## Overview

The goal of this vignette is to illustrate the process behind the functions `rnp_flight_data` and `add_flight_metadata` of the `throne` package. These two functions will allow the processing a raw `.tif` file obtained by combining images gathered during the flight itself into a data structure easily manageable with `R` (i.e., a [`tibble`](https://tibble.tidyverse.org/)) that will later be related with operative temperature model (**OTM**) data to finally predict predict thermal landscapes. 

>**NOTE**: To go further or to clarify any issues, throughout this vignette, we provie links to additional resources or complementary information. 

## Reading and processing flight data

The `rnp_flight_data` function (i.e., **r**ead a**n**d **p**rocess flight data) uses the functionality developed by packages such as [`raster`](https://rspatial.org/raster/pkg/index.html), [`sf`](https://r-spatial.github.io/sf/) or [`terra`](https://rspatial.org/pkg/1-introduction.html) to transform a `.tif` file into a data frame like `R` data structure (a `tibble`). Below we detail the functions inputs, processing and output. 

### Inputs

The `rnp_flight_data` takes in 2 inputs:

1. `file_path`: The path to the folder where the `.tif` file is stored. 
2. `digits`: The number of decimal digits to which the final output should be summarized to. 

The argument `digits` determines the number of decimal digit places to which latitude and longitude information should be rounded to. This argument will therefore determine the spatial resolution of your final measurement as different latitude and longitude decimal digits correspond to different distances. As a generalization, 1 degree of latitude can be approximated to 111.32 km, a relationship that can be extended to decimal digits as seen below. 

```{r, echo = FALSE, message = FALSE, fig.width = 8, fig.height = 4, fig.align='center'}
# generate latitudes 
lats <- c(1, 1/1e1, 1/1e2, 1/1e3, 1/1e4, 1/1e5, 1/1e6)
meter_lat <- lats*111320
lat_data <- tibble(degree_lat = lats, meter_lat = meter_lat) 

# latitude in kms plot
lat_kms_plot <- lat_data %>%
  ggplot(aes(x = as.factor(degree_lat), y = meter_lat/1000, group = 1)) +
  geom_point(size = 3) + geom_path() +
  xlab("Latitude (°)") + ylab("Distance (km)") +
  theme_minimal()+
  theme(panel.border = element_rect(fill = NA),
        axis.ticks = element_line())

# latitude in m plot
lat_m_plot <- lat_data %>% 
  filter(degree_lat < 0.001) %>% 
  ggplot(aes(x = as.factor(degree_lat), y = meter_lat, group = 1)) + 
  geom_point(size = 3) + geom_path() +
  xlab("Latitude (°)") + ylab("Distance (m)") +
  theme_minimal() +
  theme(panel.border = element_rect(fill = NA),
        axis.ticks = element_line())

# combine latitude plots
grid.arrange(lat_kms_plot, lat_m_plot, nrow = 1, ncol = 2)

```

In contrast, due to the curvature of the Earth the distance represented by a longitude degree is also dependent on latitude. You can find more information on how to transform degrees longitude into distances [here](https://en.wikipedia.org/wiki/Decimal_degrees). Furthermore, the  [`proxistat`](https://ejanalysis.github.io/proxistat/) `R`package provides helpful functions to transform coordinate systems into measurable distances. Below we use `proxistat` functions to illustrate how latitude influences the distance represented by a longitudinal degree. 

```{r echo=FALSE, fig.align='center', fig.height=4, fig.width=8, message=FALSE}
# transform function
meters.per.degree.lon <- function(theta) { 
  theta.r <- 0.01745329 * theta
  ecc2 <- 0.00669438
  return( 20037508 * cos(theta.r) / ( 180 * sqrt(1- ecc2 * (sin(theta.r))^2 ) ) )
}

# generate longitudes
lons <- lats
general_lat <- seq(0,90,by = 15)
lons_lats <- expand.grid(lons, general_lat)
colnames(lons_lats) <- c("degree_lon", "latitude")
lons_lats$meter_lon <- lons_lats$degree_lon * meters.per.degree.lon(lons_lats$latitude)

# longitude in kms plot
lons_km_plot <- lons_lats %>%
  ggplot(aes(x = as.factor(degree_lon), y = meter_lon/1000, col = latitude)) +
  geom_path(aes(group = latitude), linewidth = 1.25) +
  xlab("Longitude (°)") +  ylab("Distance (km)") +
  theme_minimal()+
  theme(panel.border = element_rect(fill = NA),
        axis.ticks = element_line(),
        legend.position = c(0.25, 0.75)) + 
  guides(color = guide_colorbar(title = "Degrees Latitude"))

# latitude in m plot
lons_m_plot <- lons_lats %>% 
  filter(degree_lon < 0.001) %>% 
  ggplot(aes(x = as.factor(degree_lon), y = meter_lon, col = latitude)) + 
  geom_path(aes(group = latitude), linewidth = 1.25) +
  xlab("Longitude (°)") + ylab("Distance (m)") +
  theme_minimal() +
  theme(panel.border = element_rect(fill = NA),
        axis.ticks = element_line(),
        legend.position = c(0.25, 0.75)) +
  guides(color = guide_colorbar(title = "Degrees Latitude"))

# combine latitude plots
grid.arrange(lons_km_plot, lons_m_plot, nrow = 1, ncol = 2)

```

Based on the above, in the majority of cases, **we recommend setting the argument `digits = 5`**. This will provide a spatial resolution of ~ 1.2 $m^2$ at the equator which will gradually descend to as little as ~ 0.5 $m^2$ at 66° Latitude as seen below. 

```{r, echo = FALSE, message = FALSE, fig.width = 6, fig.height = 4, fig.align='center'}
# processing data
lat_data$degree <- lat_data$degree_lat
lons_lats$degree <- lons_lats$degree_lon
comparison <- merge(lat_data, lons_lats, by = "degree", all = TRUE)
comparison <- comparison %>% filter(degree == 1e-05)

# plotting
comparison %>% 
  ggplot(aes(x = latitude, y = meter_lat * meter_lon)) +
  geom_vline(xintercept = c(0, 23.5, 66.5, 90), linetype = 8) +
  geom_text(label = "Equator", x = 3, y = 0.2, angle = 90, size = 4, col = "darkgray") +
  geom_text(label = "Tropics of Cancer & Capricorn", 
            x = 26.5, y = 0.42, angle = 90, size = 4, col = "darkgray") +
  geom_text(label = "Artic & Antartic Circles",
            x = 63.5, y = 0.93, angle = 90, size = 4, col = "darkgray") +
  geom_text(label = "Poles", x = 87, y = 1.1, angle = 90, size = 4, col = "darkgray") +
  geom_point(size = 3) + geom_line() +
  xlab("Latitude (°)") + 
  ylab(bquote("Spatial Resolution ("~m^2~")")) +
  scale_x_continuous(breaks = seq(0,90, by = 10)) +
  scale_y_continuous(breaks = seq(0,1.2, by = 0.2)) +
  theme_minimal() +
  theme(panel.border = element_rect(fill = NA),
        axis.ticks = element_line(),
        panel.grid.minor = element_blank()) 

```

This spatial resolution guarantees that the original `.tif` file is processed at a scale that is relevant for the majority of study organisms for which this package is intended. However, we leave this decision up to the user to consider the spatial scale that is most relevant for their organism. In the image below (figure S1 in the accompanying paper), we illustrate the same flight processed when the argument `digits` is set to 4, 5 and 6 respectively. 

![image](C:/Users/ggarc/OneDrive/research/throne/vignettes/fig_s1.png)

, 
In order to transform the original `.tif` file, the `rnp_flight_data` goes through the following general steps: 

1. Read the `.tif` file as a as a raster object using the `raster` function from the `raster` package.

2. Transform the raster into a data frame via the `rasterToPoints` function also from the `raster` package. The resulting data frame will have longitude, latitude and reflected temperature (i.e., the temperature measured by the drone) and as many rows as combinations of unique longitude and latitude values your initial `.tif` file had. Each combination corresponds to a "tile" within your area of study and the area of this "tile" will be determined by the number of decimal digits of your latitude and longitude measurements as presented earlier. 

3. Project the coordinates of the newly created data frame from a [**Universal Transverse Mercator**(**UTM**)](https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system) coordinate system to a more easy to interpret [**World Geodetic System**(**WGS84**)](https://en.wikipedia.org/wiki/World_Geodetic_System) coordinate system (i.e., from a system based in UTM zones to the widely used decimal latitude and longitude degrees), using the `project` function of the `terra` package. 

4. Round the number of decimal digits on all latitude and longitude observations according to the `digits` argument. 

5. Average the reflected temperature across all observations with the same averaged latitude and longitude. 

### Output 

The final output is a `tibble` object with columns for latitude, longitude and reflected temperature (`ref_temp`). The number of rows of this data set will vary depending on the area covered by the flight and the number of `digits` specified. For instance, our study area was ~ 2900 $m^2$, which processed setting `digits = 5` led to a `tibble` of 7813 observations each representing a "tile" of approximately 0.4 $m^2$ at a latitude of approximately 40°. 

```{r, echo = FALSE, warnings = FALSE}
flights_data %>% 
  filter(minute_start == 515) %>% 
  dplyr::select(latitude, longitude, ref_temp)
```

Once the raw `.tif` file is processed, the resulting `tibble` can already be used to quantify the thermal characteristics of a study site from a spatially discrete perspective. To illustrate this, below we plot 4 of the 34 fully processed flights (with `digits = 5`) over the same area we offer in the `throne` package as example data. Panel titles indicate the hour in which the flight took place

```{r, echo = FALSE, message = FALSE, fig.width = 8, fig.height = 10, fig.align='center'}
flights_data %>% 
  filter(minute_start %in% c(515, 700, 900, 1026)) %>%
  mutate(hour = round(minute_start/60)) %>%
  mutate(hour = paste(hour,":00 h", sep = "")) %>%
  ggplot(aes(x = longitude, y = latitude, fill = ref_temp)) +
  geom_tile() +
  scale_fill_viridis(option = "magma") +
  facet_wrap(~ fct_reorder(hour, minute_start)) +
  xlab("Longitude") + ylab("Latitude") +
  theme_minimal() +
  theme(panel.border = element_rect(fill = NA),
        axis.ticks = element_line(),
        panel.grid.minor = element_blank(), 
        strip.background = element_rect(fill = "lightgray"),
        strip.text = element_text(size = 12),
        legend.position = "top") +
  guides(fill = guide_colorbar("Reflected temperature (°C)"))
```

## Adding flight metadata

The `add_flight_metadta` function adds information about the flight to the processed flight data outputted from the `rnp_flight_data` function. Below we detail the function's inputs, processing and output. 

### Inputs 

The `add_flight_data` function takes in 3 inputs:

1. `flight_data`: A processed flight data `tibble` obtained using the `rnp_flight_data` function. 
2. `flight_metadata`: A flight metadata file
3. `flight_id`: An identification (ID) for the flight present in the metadata file.

The documentation for the `throne` package includes an example flight metadata flight that includes information on when did the flight took place see below:

```{r, echo = FALSE, message = FALSE}
head(flights_metadata)
```

Our example file includes an `flight_id` column and columns for the `date` when the flight took place as well as the time of the day when the flight started (HH:MM format, `time_start`) and the time of the day when the flight ended (`time_end`). Additionally, our data set includes information on whether **ground control points** (GCPs, see `gcps` column) where used when processing the flight. Metadata files can include additional information like the height at which the drone flew during the flight, overall weather conditions etc. if the user wants to consider them for any analysis. 

>**NOTE**: It is important that the `flight_id`, `date`, `time_start` and `time_end` columns in a metadata file are formatted like in the example file above for the `add_flight_metadata` function to work correctly. 

### Processing 

In order to add the metadata specific to the flight being processed, the `add_flight_metadata` function goes through the following general steps.

1. Extract the metadata for the desired flight (specified via `fligt_id`)
2. Using tools from the `lubridate` package, extract the year and **Julian date** (i.e., day of the year) when the flight took place.
3. Transform the `time_start` and `time_end` columns to **minutes of the day** columns.
4. Bind the flight's metadata to the processed flight data.

>**NOTE**: We choose to use Julian dates and minutes of the day to simplify the management of the data as much as possible. Date and time data have unique data formats in the `R` environment that are often difficult to handle for users and that might lead to unintended errors. By using Julian dates and minutes of the day, we deal only with integer columns, much easier to operate with and manipulate. Further, these formats can be easily transformed back into more easily interpretable scales for visualization purposes, [by using the `as.Date` function to transform Julian dates back into a YYYY-MM-DD format](https://stackoverflow.com/questions/24200014/convert-day-of-year-to-date) and dividing by 60 for minutes of the day to get hours. 

### Output

The final output is the same as with the `rnp_flight_data` function adding columns for `year`, `date`, `minute_start` and `minute_end`. 

```{r, echo=FALSE, message = FALSE}
flights_data %>% filter(minute_start == 515) %>% mutate(flight_id = "VAL02_GCP_01") %>%
  dplyr::select(flight_id, latitude, longitude, ref_temp, year, date, minute_start, minute_end)
```


## Integrated processing for multiple flights

Both of the functions presented above work for a single flight, nonetheless, in the majority of occasions, users will probably have multiple flights to process. Below, we provide some example code on how to precisely do that via a loop. 

```{r, eval = FALSE}
# read the flights metadata file for all flgihts
flights_metadata <- read.csv("~/flights_metadata.csv") # specify your own folder here

# define the folder where the .tif files are stored and list those files
folder <- "~/flights_raw_data" # specify your own folder here
flight_files_list <- paste(folder, "/", list.files(folder), sep = "")

# generate a dataset to store the flights data
flights_data <- data.frame(latitude = c(), longitude = c(), ref_temp = c(),
                           year = c(), date = c(), minute_start = c(), minute_end = c())

# loop through all flight files
for(i in 1:length(flight_files_list)){

  # read and process flight data for first flight
  flight <- rnp_flight_data(file_path = flight_files_list[i], digits = 5)

  # add flight metadata, use the list of files to specify the file ID
  flight <- add_flight_metadata(flight_data = flight,
                                flight_id = str_sub(list.files(folder)[i], end = -5),
                                flight_metadata = flights_metadata)

  # bind to holder data set
  flights_data <- rbind(flights_data, flight)

}

# save the flights dataset
save(flights_data, file = "~/flights_data.RData") # specify your own folder here

```

> **NOTE**: The code above **will** take a substantial amount of time to run. The number of flights, the area covered in each flight and the number of decimal digits at which the flight data is being processed will determine the run time. Nonetheless, if everything is implemented correctly, flights will only need to processed once!.

For the final output, we do not include the `flight_id` as it is redundant information given that no two flights can happen at the same time. After implementing the code above on the 34 flights flown over 2 days provided in the `throne` package, we obtain a data set of 262803 observations. 

```{r, echo = FALSE}
as_tibble(flights_data)
```


































































